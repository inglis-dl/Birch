/*=========================================================================

  Program:  Birch (A simple image viewer)
  Module:   Utilities.h
  Language: C++

  Author: Patrick Emond <emondpd AT mcmaster DOT ca>
  Author: Dean Inglis <inglisd AT mcmaster DOT ca>

=========================================================================*/
//
// .SECTION Description
// A utilities header to include typedefs, macros, global functions, etc.
//

#ifndef __Utilities_h
#define __Utilities_h

#define BIRCH_VERSION_MAJOR @BIRCH_VERSION_MAJOR@
#define BIRCH_VERSION_MINOR @BIRCH_VERSION_MINOR@
#define BIRCH_VERSION_PATCH @BIRCH_VERSION_PATCH@

//#define BIRCH_ROOT_DIR "@BIRCH_ROOT_DIR@"
//#define BIRCH_AUX_DIR "@BIRCH_AUX_DIR@"
#define BIRCH_API_DIR "@BIRCH_API_DIR@"
#define BIRCH_APP_DIR "@BIRCH_APP_DIR@"
#define BIRCH_QT_DIR "@BIRCH_QT_DIR@"
#define BIRCH_VTK_DIR "@BIRCH_VTK_DIR@"
//#define BIRCH_CONFIG_FILE "@BIRCH_CONFIG_FILE@"
//#define BIRCH_OPAL_SCRIPT "@BIRCH_OPAL_SCRIPT@"


#include <algorithm>
//#include <base64.h>
#include <cctype>
//#include <json/reader.h>
//#include <sha.h>
#include <sstream>
#include <stdio.h>
#include <time.h>
#include <unistd.h>

/**
 * @addtogroup Birch
 * @{
 */

namespace Birch
{
  class Utilities
  {
  public:

    inline static std::string exec( const char* command )
    {
      FILE* pipe = popen( command, "r" );
      if( !pipe ) return "ERROR";
      char buffer[128];
      std::string result = "";
      while( !feof( pipe ) ) if( fgets( buffer, 128, pipe ) != NULL ) result += buffer;
      pclose( pipe );
      return result;
    } 

    inline static std::string getTime( std::string format )
    {
      char buffer[256];
      time_t rawtime;
      time( &rawtime );
      strftime( buffer, 256, format.c_str(), localtime( &rawtime ) );
      return std::string( buffer );
    }

    inline static std::string toLower( std::string str )
    {
      std::string returnString = str;
      std::transform( str.begin(), str.end(), returnString.begin(), tolower );
      return returnString;
    }

    inline static std::string toUpper( std::string str )
    {
      std::string returnString = str;
      std::transform( str.begin(), str.end(), returnString.begin(), toupper );
      return returnString;
    }

    inline static bool fileExists( std::string filename )
    {
      if( filename.empty() ) return false;
      return access( filename.c_str(), R_OK )  == 0;
    }

    inline static std::string getFileExtension( std::string filename )
    {
      std::string::size_type dot_pos = filename.rfind(".");
      std::string extension = (dot_pos == std::string::npos) ? "" :
        filename.substr( dot_pos );
      return extension;  
    }

    inline static std::string getFilenamePath( std::string filename )
    {
      std::string::size_type slash_pos = filename.rfind("/");
      if( slash_pos != std::string::npos )
      {
        std::string path = filename.substr( 0, slash_pos );
        if( path.size() == 2 && path[1] == ':' )
        {
          return path + '/';
        }
        if( path.size() == 0 )
        {
          return "/";
        }
        return path;
      }
      else
      {
        return "";
      }
    }
    
    inline static std::string getFilenameName( std::string filename )
    {
      std::string::size_type slash_pos = filename.find_last_of("/");
      if( slash_pos != std::string::npos )
      {
        return filename.substr( slash_pos + 1 );
      }
      else
      {
        return filename;
      }
    }
  };  
}

#endif // __Utilities_h
